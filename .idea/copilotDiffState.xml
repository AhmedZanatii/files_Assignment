<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/cmake-build-debug/AlgoAss.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/cmake-build-debug/AlgoAss.h" />
              <option name="originalContent" value="// matrix_mul.cpp&#10;// Compile: g++ -O2 matrix_mul.cpp -o matrix_mul&#10;#include &lt;bits/stdc++.h&gt;&#10;using namespace std;&#10;using Matrix = vector&lt;vector&lt;double&gt;&gt;;&#10;&#10;Matrix naive_mul(const Matrix &amp;A, const Matrix &amp;B) {&#10;    int n = A.size();&#10;    Matrix C(n, vector&lt;double&gt;(n, 0.0));&#10;    for (int i=0;i&lt;n;++i) {&#10;        for (int k=0;k&lt;n;++k) {&#10;            double aik = A[i][k];&#10;            for (int j=0;j&lt;n;++j) C[i][j] += aik * B[k][j];&#10;        }&#10;    }&#10;    return C;&#10;}&#10;&#10;Matrix add(const Matrix &amp;A, const Matrix &amp;B) {&#10;    int n = A.size();&#10;    Matrix C(n, vector&lt;double&gt;(n));&#10;    for (int i=0;i&lt;n;++i) for (int j=0;j&lt;n;++j) C[i][j]=A[i][j]+B[i][j];&#10;    return C;&#10;}&#10;Matrix subm(const Matrix &amp;A, const Matrix &amp;B) {&#10;    int n = A.size();&#10;    Matrix C(n, vector&lt;double&gt;(n));&#10;    for (int i=0;i&lt;n;++i) for (int j=0;j&lt;n;++j) C[i][j]=A[i][j]-B[i][j];&#10;    return C;&#10;}&#10;&#10;void split(const Matrix &amp;A, Matrix &amp;A11, Matrix &amp;A12, Matrix &amp;A21, Matrix &amp;A22) {&#10;    int n = A.size(), m = n/2;&#10;    A11.assign(m, vector&lt;double&gt;(m)); A12.assign(m, vector&lt;double&gt;(m));&#10;    A21.assign(m, vector&lt;double&gt;(m)); A22.assign(m, vector&lt;double&gt;(m));&#10;    for (int i=0;i&lt;m;++i) for (int j=0;j&lt;m;++j) {&#10;        A11[i][j]=A[i][j];&#10;        A12[i][j]=A[i][j+m];&#10;        A21[i][j]=A[i+m][j];&#10;        A22[i][j]=A[i+m][j+m];&#10;    }&#10;}&#10;&#10;Matrix join(const Matrix &amp;C11, const Matrix &amp;C12, const Matrix &amp;C21, const Matrix &amp;C22) {&#10;    int m = C11.size(), n = m*2;&#10;    Matrix C(n, vector&lt;double&gt;(n));&#10;    for (int i=0;i&lt;m;++i) {&#10;        for (int j=0;j&lt;m;++j) {&#10;            C[i][j]=C11[i][j];&#10;            C[i][j+m]=C12[i][j];&#10;            C[i+m][j]=C21[i][j];&#10;            C[i+m][j+m]=C22[i][j];&#10;        }&#10;    }&#10;    return C;&#10;}&#10;&#10;Matrix pad_to_pow2(const Matrix &amp;A) {&#10;    int n = A.size();&#10;    int p = 1; while (p&lt;n) p&lt;&lt;=1;&#10;    if (p==n) return A;&#10;    Matrix B(p, vector&lt;double&gt;(p,0.0));&#10;    for (int i=0;i&lt;n;++i) for (int j=0;j&lt;n;++j) B[i][j]=A[i][j];&#10;    return B;&#10;}&#10;&#10;Matrix strassen_mul(const Matrix &amp;A, const Matrix &amp;B, int cutoff=64) {&#10;    int n = A.size();&#10;    if (n &lt;= cutoff) return naive_mul(A,B);&#10;    // pad&#10;    int p = 1; while (p&lt;n) p&lt;&lt;=1;&#10;    if (p!=n) {&#10;        Matrix Ap = pad_to_pow2(A);&#10;        Matrix Bp = pad_to_pow2(B);&#10;        Matrix Cp = strassen_mul(Ap,Bp,cutoff);&#10;        Matrix C(n, vector&lt;double&gt;(n));&#10;        for (int i=0;i&lt;n;++i) for (int j=0;j&lt;n;++j) C[i][j]=Cp[i][j];&#10;        return C;&#10;    }&#10;    Matrix A11,A12,A21,A22,B11,B12,B21,B22;&#10;    split(A,A11,A12,A21,A22);&#10;    split(B,B11,B12,B21,B22);&#10;    Matrix M1 = strassen_mul(add(A11,A22), add(B11,B22), cutoff);&#10;    Matrix M2 = strassen_mul(add(A21,A22), B11, cutoff);&#10;    Matrix M3 = strassen_mul(A11, subm(B12,B22), cutoff);&#10;    Matrix M4 = strassen_mul(A22, subm(B21,B11), cutoff);&#10;    Matrix M5 = strassen_mul(add(A11,A12), B22, cutoff);&#10;    Matrix M6 = strassen_mul(subm(A21,A11), add(B11,B12), cutoff);&#10;    Matrix M7 = strassen_mul(subm(A12,A22), add(B21,B22), cutoff);&#10;&#10;    Matrix C11 = add( subm( add(M1,M4), M5 ), M7 );&#10;    Matrix C12 = add(M3,M5);&#10;    Matrix C21 = add(M2,M4);&#10;    Matrix C22 = add( subm( add(M1,M3), M2 ), M6 );&#10;    return join(C11,C12,C21,C22);&#10;}&#10;&#10;int main(){&#10;    int n = 128; // example&#10;    Matrix A(n, vector&lt;double&gt;(n)), B(n, vector&lt;double&gt;(n));&#10;    std::mt19937_64 rng(123);&#10;    std::uniform_real_distribution&lt;double&gt; dist(0.0,1.0);&#10;    for (int i=0;i&lt;n;++i) for (int j=0;j&lt;n;++j) { A[i][j]=dist(rng); B[i][j]=dist(rng); }&#10;    Matrix C1 = naive_mul(A,B);&#10;    Matrix C2 = strassen_mul(A,B, 32);&#10;    // verify&#10;    double maxdiff = 0.0;&#10;    for (int i=0;i&lt;n;++i) for (int j=0;j&lt;n;++j) maxdiff = max(maxdiff, fabs(C1[i][j]-C2[i][j]));&#10;    cout &lt;&lt; &quot;max diff: &quot; &lt;&lt; maxdiff &lt;&lt; endl;&#10;    return 0;&#10;}&#10;&#10;" />
              <option name="updatedContent" value="// matrix_mul.cpp&#13;&#10;// Compile: g++ -O2 matrix_mul.cpp -o matrix_mul&#13;&#10;#include &lt;bits/stdc++.h&gt;&#13;&#10;using namespace std;&#13;&#10;using Matrix = vector&lt;vector&lt;double&gt;&gt;;&#13;&#10;&#13;&#10;Matrix naive_mul(const Matrix &amp;A, const Matrix &amp;B) {&#13;&#10;    int n = A.size();&#13;&#10;    Matrix C(n, vector&lt;double&gt;(n, 0.0));&#13;&#10;    for (int i=0;i&lt;n;++i) {&#13;&#10;        for (int k=0;k&lt;n;++k) {&#13;&#10;            double aik = A[i][k];&#13;&#10;            for (int j=0;j&lt;n;++j) C[i][j] += aik * B[k][j];&#13;&#10;        }&#13;&#10;    }&#13;&#10;    return C;&#13;&#10;}&#13;&#10;&#13;&#10;Matrix add(const Matrix &amp;A, const Matrix &amp;B) {&#13;&#10;    int n = A.size();&#13;&#10;    Matrix C(n, vector&lt;double&gt;(n));&#13;&#10;    for (int i=0;i&lt;n;++i) for (int j=0;j&lt;n;++j) C[i][j]=A[i][j]+B[i][j];&#13;&#10;    return C;&#13;&#10;}&#13;&#10;Matrix subm(const Matrix &amp;A, const Matrix &amp;B) {&#13;&#10;    int n = A.size();&#13;&#10;    Matrix C(n, vector&lt;double&gt;(n));&#13;&#10;    for (int i=0;i&lt;n;++i) for (int j=0;j&lt;n;++j) C[i][j]=A[i][j]-B[i][j];&#13;&#10;    return C;&#13;&#10;}&#13;&#10;&#13;&#10;void split(const Matrix &amp;A, Matrix &amp;A11, Matrix &amp;A12, Matrix &amp;A21, Matrix &amp;A22) {&#13;&#10;    int n = A.size(), m = n/2;&#13;&#10;    A11.assign(m, vector&lt;double&gt;(m)); A12.assign(m, vector&lt;double&gt;(m));&#13;&#10;    A21.assign(m, vector&lt;double&gt;(m)); A22.assign(m, vector&lt;double&gt;(m));&#13;&#10;    for (int i=0;i&lt;m;++i) for (int j=0;j&lt;m;++j) {&#13;&#10;        A11[i][j]=A[i][j];&#13;&#10;        A12[i][j]=A[i][j+m];&#13;&#10;        A21[i][j]=A[i+m][j];&#13;&#10;        A22[i][j]=A[i+m][j+m];&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;Matrix join(const Matrix &amp;C11, const Matrix &amp;C12, const Matrix &amp;C21, const Matrix &amp;C22) {&#13;&#10;    int m = C11.size(), n = m*2;&#13;&#10;    Matrix C(n, vector&lt;double&gt;(n));&#13;&#10;    for (int i=0;i&lt;m;++i) {&#13;&#10;        for (int j=0;j&lt;m;++j) {&#13;&#10;            C[i][j]=C11[i][j];&#13;&#10;            C[i][j+m]=C12[i][j];&#13;&#10;            C[i+m][j]=C21[i][j];&#13;&#10;            C[i+m][j+m]=C22[i][j];&#13;&#10;        }&#13;&#10;    }&#13;&#10;    return C;&#13;&#10;}&#13;&#10;&#13;&#10;Matrix pad_to_pow2(const Matrix &amp;A) {&#13;&#10;    int n = A.size();&#13;&#10;    int p = 1; while (p&lt;n) p&lt;&lt;=1;&#13;&#10;    if (p==n) return A;&#13;&#10;    Matrix B(p, vector&lt;double&gt;(p,0.0));&#13;&#10;    for (int i=0;i&lt;n;++i) for (int j=0;j&lt;n;++j) B[i][j]=A[i][j];&#13;&#10;    return B;&#13;&#10;}&#13;&#10;&#13;&#10;Matrix strassen_mul(const Matrix &amp;A, const Matrix &amp;B, int cutoff=64) {&#13;&#10;    int n = A.size();&#13;&#10;    if (n &lt;= cutoff) return naive_mul(A,B);&#13;&#10;    // pad&#13;&#10;    int p = 1; while (p&lt;n) p&lt;&lt;=1;&#13;&#10;    if (p!=n) {&#13;&#10;        Matrix Ap = pad_to_pow2(A);&#13;&#10;        Matrix Bp = pad_to_pow2(B);&#13;&#10;        Matrix Cp = strassen_mul(Ap,Bp,cutoff);&#13;&#10;        Matrix C(n, vector&lt;double&gt;(n));&#13;&#10;        for (int i=0;i&lt;n;++i) for (int j=0;j&lt;n;++j) C[i][j]=Cp[i][j];&#13;&#10;        return C;&#13;&#10;    }&#13;&#10;    Matrix A11,A12,A21,A22,B11,B12,B21,B22;&#13;&#10;    split(A,A11,A12,A21,A22);&#13;&#10;    split(B,B11,B12,B21,B22);&#13;&#10;    Matrix M1 = strassen_mul(add(A11,A22), add(B11,B22), cutoff);&#13;&#10;    Matrix M2 = strassen_mul(add(A21,A22), B11, cutoff);&#13;&#10;    Matrix M3 = strassen_mul(A11, subm(B12,B22), cutoff);&#13;&#10;    Matrix M4 = strassen_mul(A22, subm(B21,B11), cutoff);&#13;&#10;    Matrix M5 = strassen_mul(add(A11,A12), B22, cutoff);&#13;&#10;    Matrix M6 = strassen_mul(subm(A21,A11), add(B11,B12), cutoff);&#13;&#10;    Matrix M7 = strassen_mul(subm(A12,A22), add(B21,B22), cutoff);&#13;&#10;&#13;&#10;    Matrix C11 = add( subm( add(M1,M4), M5 ), M7 );&#10;    Matrix C12 = add(M3,M5);&#10;    Matrix C21 = add(M2,M4);&#10;    Matrix C22 = add( subm( add(M1,M3), M2 ), M6 );&#10;    return join(C11,C12,C21,C22);&#10;}&#10;&#10;// Commented out to avoid multiple main definition&#10;/*&#10;int main(){&#10;    int n = 128; // example&#10;    Matrix A(n, vector&lt;double&gt;(n)), B(n, vector&lt;double&gt;(n));&#10;    std::mt19937_64 rng(123);&#10;    std::uniform_real_distribution&lt;double&gt; dist(0.0,1.0);&#10;    for (int i=0;i&lt;n;++i) for (int j=0;j&lt;n;++j) { A[i][j]=dist(rng); B[i][j]=dist(rng); }&#10;    Matrix C1 = naive_mul(A,B);&#10;    Matrix C2 = strassen_mul(A,B, 32);&#10;    // verify&#10;    double maxdiff = 0.0;&#10;    for (int i=0;i&lt;n;++i) for (int j=0;j&lt;n;++j) maxdiff = max(maxdiff, fabs(C1[i][j]-C2[i][j]));&#10;    cout &lt;&lt; &quot;max diff: &quot; &lt;&lt; maxdiff &lt;&lt; endl;&#10;    return 0;&#10;}&#10;*/&#13;&#10;&#13;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>